#+title: emacs desktop environment
#+property: header-args:emacs-lisp :tangle ./desktop.el

* Window Management

** exwm configuration

we use the excellent [[https://github.com/ch11ng/exwm][exwm]] module as the basis for our emacs desktop environment.  the [[https://github.com/ch11ng/exwm/wiki][exwm wiki]] is a great place to find tips about how to configure everything!

*note:* make sure you've installed =nm-applet=, =pasystray= and =blueman= for the system tray apps to work!

#+begin_src emacs-lisp
  
      ;; (defun efs/run-in-background (command)
      ;;   (let ((command-parts (split-string command "[ ]+")))
      ;;     (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))
  
      (defun  efs/set-wallpaper ()
	(interactive)
	;; note: you will need to update this to a valid background path!
	(start-process-shell-command
	 "feh" nil  "feh --bg-scale ~/wpp/3354772.jpg"))
  
      ;; # (defun efs/exwm-init-hook ()
      ;; #     ;; make workspace 1 be the one where we land at startup
      ;; #     (exwm-workspace-switch-create 1)
  
      ;; #     ;; open eshell by default
      ;; #     ;;(eshell)
  
      ;; #     ;; NOTE: The next two are disabled because we now use Polybar!
  
      ;; #     ;; Show battery status in the mode line
      ;; #     ;;(display-battery-mode 1)
  
      ;; #     ;; Show the time and date in modeline
      ;; #     ;;(setq display-time-day-and-date t)
      ;; #     ;;(display-time-mode 1)
      ;; #     ;; Also take a look at display-time-format and format-time-string
  
      ;; #     ;; Start the Polybar panel
      ;; #     (efs/start-panel)
  
      ;; #     ;; Launch apps that will run in the background
      ;; #     (efs/run-in-background "dunst")
      ;; #     ;; (efs/run-in-background "nm-applet")
      ;; #     (efs/run-in-background "pasystray"i))
      ;; #     ;; (efs/run-in-background "blueman-applet"))
  
      ;; #   (defun efs/exwm-update-class ()
      ;; #     (exwm-workspace-rename-buffer exwm-class-name))
  
      ;; #   (defun efs/exwm-update-title ()
      ;; #     (pcase exwm-class-name
      ;; #       ("Firefox" (exwm-workspace-rename-buffer (format "Firefox: %s" exwm-title)))))
  
      ;; #   ;; This function isn't currently used, only serves as an example how to
      ;; #   ;; position a window
      ;; #   (defun efs/position-window ()
      ;; #     (let* ((pos (frame-position))
      ;; # 	   (pos-x (car pos))
      ;; # 	    (pos-y (cdr pos)))
  
      ;; #       (exwm-floating-move (- pos-x) (- pos-y))))
  
      ;; #   (defun efs/configure-window-by-class ()
      ;; #     (interactive)
      ;; #     (pcase exwm-class-name
      ;; #       ("Firefox" (exwm-workspace-move-window 2))
      ;; #       ("Sol" (exwm-workspace-move-window 3))
      ;; #       ("mpv" (exwm-floating-toggle-floating)
      ;; # 	     (exwm-layout-toggle-mode-line))))
  
      ;; #   ;; This function should be used only after configuring autorandr!
      ;; #   (defun efs/update-displays ()
      ;; #     (efs/run-in-background "autorandr --change --force")
      ;; #     (efs/set-wallpaper)
      ;; #     (message "Display config: %s"
      ;; # 	     (string-trim (shell-command-to-string "autorandr --current"))))
  
      ;; #   (use-package exwm
      ;; #     :config
      ;; #     ;; Set the default number of workspaces
      ;; #     (setq exwm-workspace-number 5)
  
      ;; #     ;; When window "class" updates, use it to set the buffer name
      ;; #     (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)
  
      ;; #     ;; When window title updates, use it to set the buffer name
      ;; #     (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)
  
      ;; #     ;; Configure windows as they're created
      ;; #     (add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)
  
      ;; #     ;; When EXWM starts up, do some extra confifuration
      ;; #     (add-hook 'exwm-init-hook #'efs/exwm-init-hook)
  
      ;; #     ;; Rebind CapsLock to Ctrl
      ;; #     (start-process-shell-command "xmodmap" nil "xmodmap ~/.emacs.d/exwm/Xmodmap")
  
      ;; #     ;; NOTE: Uncomment the following two options if you want window buffers
      ;; #     ;;       to be available on all workspaces!
  
      ;; #     ;; Automatically move EXWM buffer to current workspace when selected
      ;; #     ;; (setq exwm-layout-show-all-buffers t)
  
      ;; #     ;; Display all EXWM buffers in every workspace buffer list
      ;; #     ;; (setq exwm-workspace-show-all-buffers t)
  
      ;; #     ;; NOTE: Uncomment this option if you want to detach the minibuffer!
      ;; #     ;; Detach the minibuffer (show it with exwm-workspace-toggle-minibuffer)
      ;; #     ;;(setq exwm-workspace-minibuffer-position 'top)
  
      ;; #     ;; Set the screen resolution (update this to be the correct resolution for your screen!)
      ;; #     (require 'exwm-randr)
      ;; #     (exwm-randr-enable)
      ;; #     (start-process-shell-command "xrandr" nil "xrandr --output Virtual-1 --primary --mode 2048x1152 --pos 0x0 --rotate normal")
  
      ;; #     ;; This will need to be updated to the name of a display!  You can find
      ;; #     ;; the names of your displays by looking at arandr or the output of xrandr
      ;; #     (setq exwm-randr-workspace-monitor-plist '(2 "Virtual-2" 3 "Virtual-2"))
  
      ;; #     ;; NOTE: Uncomment these lines after setting up autorandr!
      ;; #     ;; React to display connectivity changes, do initial display update
      ;; #     ;; (add-hook 'exwm-randr-screen-change-hook #'efs/update-displays)
      ;; #     ;; (efs/update-displays)
  
      ;; #     ;; Set the wallpaper after changing the resolution
	  (efs/set-wallpaper)
  
      ;; #     ;; NOTE: This is disabled because we now use Polybar!
      ;; #     ;; Load the system tray before exwm-init
      ;; #     ;; (require 'exwm-systemtray)
      ;; #     ;; (setq exwm-systemtray-height 32)
      ;; #     ;; (exwm-systemtray-enable)
  
  ;;     ;; Automatically send the mouse cursor to the selected workspace's display
  ;;     (setq exwm-workspace-warp-cursor t)
  
  ;;     ;; Window focus should follow the mouse pointer
  ;;     (setq mouse-autoselect-window t
  ;;           focus-follows-mouse t)
  
  ;;     ;; These keys should always pass through to Emacs
  ;;     (setq exwm-input-prefix-keys
  ;;           '(?\C-x
  ;;             ?\C-u
  ;;             ?\C-h
  ;;             ?\M-x
  ;;             ?\M-`
  ;;             ?\M-&
  ;;             ?\M-:
  ;;             ?\C-\M-j  Buffer list
  ;;             ?\C-\ )) ;; Ctrl+Space
  
  ;; Ctrl+Q will enable the next key to be sent directly
  ;; (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)
  
  ;;     ;; Set up global key bindings.  These always work, no matter the input state!
  ;;     ;; Keep in mind that changing this list after EXWM initializes has no effect.
  (setq exwm-input-global-keys
	`(
	  ;;             Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
	  ([?\s-r] . exwm-reset)
  
	  ;;             Move between windows
	  ([s-left] . windmove-left)
	  ;; ([s-j] . windmove-left)
	  ([s-right] . windmove-right)
	  ;; ([s-left] . windmove-left)
	  ([?\s-k] . windmove-up)
	  ([s-up] . windmove-up)
	  ([?\s-j] . windmove-down)
	  ([s-down] . windmove-down)
  
  ;;             ;; Launch applications via shell command
	  ([?\s-&] . (lambda (command)
		       (interactive (list (read-shell-command "$ ")))
		       (start-process-shell-command command nil command)))
  
  ;;             ;; Switch workspace
	  ([?\s-w] . exwm-workspace-switch)
	  ([?\s-`] . (lambda () (interactive) (exwm-workspace-switch-create 0)))
  
  ;;             ;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
	,@(mapcar (lambda (i)
		    `(,(kbd (format "s-%d" i)) .
		      (lambda ()
			(interactive)
			(exwm-workspace-switch-create ,i))))
		  (number-sequence 0 9))))
  
  ;; (exwm-input-set-key (kbd "s-SPC") 'counsel-linux-app)
  
  ;;     (exwm-enable))
  
#+end_src

#+RESULTS:
: (([8388722] . exwm-reset) ([s-left] . windmove-left) ([s-right] . windmove-right) ([8388715] . windmove-up) ([s-up] . windmove-up) ([8388714] . windmove-down) ([s-down] . windmove-down) ([8388646] lambda (command) (interactive (list (read-shell-command $ ))) (start-process-shell-command command nil command)) ([8388727] . exwm-workspace-switch) ([8388704] lambda nil (interactive) (exwm-workspace-switch-create 0)) ([8388656] lambda nil (interactive) (exwm-workspace-switch-create 0)) ([8388657] lambda nil (interactive) (exwm-workspace-switch-create 1)) ([8388658] lambda nil (interactive) (exwm-workspace-switch-create 2)) ([8388659] lambda nil (interactive) (exwm-workspace-switch-create 3)) ([8388660] lambda nil (interactive) (exwm-workspace-switch-create 4)) ([8388661] lambda nil (interactive) (exwm-workspace-switch-create 5)) ([8388662] lambda nil (interactive) (exwm-workspace-switch-create 6)) ([8388663] lambda nil (interactive) (exwm-workspace-switch-create 7)) ([8388664] lambda nil (interactive) (exwm-workspace-switch-create 8)) ([8388665] lambda nil (interactive) (exwm-workspace-switch-create 9)))

# #+RESULTS:
# : t

* Desktop Environment
** Desktop Key Bindings

We use the [[https://github.com/DamienCassou/desktop-environment][desktop-environment]] package to automatically bind to
well-known programs for controlling the volume, screen brightness,
media playback, and doing other things like locking the screen and
taking screenshots.  Make sure that you install the necessary programs
to make this functionality work!  Check the [[https://github.com/DamienCassou/desktop-environment#default-configuration][default programs]] list to
know what you need to install.

#+begin_src emacs-lisp

  (use-package desktop-environment
    :after exwm
    :config (desktop-environment-mode)
    :custom
    (desktop-environment-brightness-small-increment "2%+")
    (desktop-environment-brightness-small-decrement "2%-")
    (desktop-environment-brightness-normal-increment "5%+")
    (desktop-environment-brightness-normal-decrement "5%-"))

#+end_src

** Desktop File

This file is used by your "login manager" (GDM, LightDM, etc) to display EXWM as a desktop environment option when you log in.

*IMPORTANT*: Make sure you create a symbolic link for this file into =/usr/share/xsessions=:

#+begin_src sh :tangle no

sudo ln -f ~/.emacs.d/exwm/EXWM.desktop /usr/share/xsessions/EXWM.desktop

#+end_src

#+begin_src shell :tangle ./exwm/EXWM.desktop :mkdirp yes

  [Desktop Entry]
  Name=EXWM
  Comment=Emacs Window Manager
  Exec=sh /home/daviwil/.emacs.d/exwm/start-exwm.sh
  TryExec=sh
  Type=Application
  X-LightDM-DesktopName=exwm
  DesktopNames=exwm

#+end_src

** Launcher Script

This launcher script is invoked by =EXWM.desktop= to start Emacs and load our desktop environment configuration.  We also start up some other helpful applications to configure the desktop experience.

#+begin_src shell :tangle ./exwm/start-exwm.sh :shebang #!/bin/sh

  # Set the screen DPI (uncomment this if needed!)
  # xrdb ~/.emacs.d/exwm/Xresources

  # Run the screen compositor
  compton &

  # Enable screen locking on suspend
  xss-lock -- slock &

  # Fire it up
  exec dbus-launch --exit-with-session emacs -mm --debug-init -l ~/.emacs.d/desktop.el

#+end_src

** Keyboard Configuration

The =Xmodmap= file will be used with the =xmodmap= program to remap CapsLock to Ctrl inside of our desktop environment:

#+begin_src sh :tangle ./exwm/Xmodmap

  clear lock
  clear control
  keycode 66 = Control_L
  add control = Control_L
  add Lock = Control_R

#+end_src

** DPI configuration

The =Xresources= file will be used with =xrdb= in =start-exwm.sh= to set our screen DPI:

#+begin_src conf :tangle ./exwm/Xresources

  Xft.dpi:   100   # Set this to your desired DPI!  Larger number means bigger text and UI

#+end_src

** Panel with Polybar

Polybar provides a great, minimalistic panel for your EXWM desktop configuration.  The following config integrates =emacsclient= and Polybar with =polybar-msg= to enable you to gather *any* information from Emacs and display it in the panel!

Check out the Polybar wiki for more details on how to configure it: https://github.com/polybar/polybar/wiki

#+begin_src emacs-lisp

  ;; Make sure the server is started (better to do this in your main Emacs config!)
  (server-start)

  (defvar efs/polybar-process nil
    "Holds the process of the running Polybar instance, if any")

  (defun efs/kill-panel ()
    (interactive)
    (when efs/polybar-process
      (ignore-errors
        (kill-process efs/polybar-process)))
    (setq efs/polybar-process nil))

  (defun efs/start-panel ()
    (interactive)
    (efs/kill-panel)
    (setq efs/polybar-process (start-process-shell-command "polybar" nil "polybar panel")))

  (defun efs/send-polybar-hook (module-name hook-index)
    (start-process-shell-command "polybar-msg" nil (format "polybar-msg hook %s %s" module-name hook-index)))

  (defun efs/send-polybar-exwm-workspace ()
    (efs/send-polybar-hook "exwm-workspace" 1))

  ;; Update panel indicator when workspace changes
  (add-hook 'exwm-workspace-switch-hook #'efs/send-polybar-exwm-workspace)

#+end_src

The configuration for our ingeniously named panel, "panel".  Invoke it with =polybar panel= on the command line!

*** The config
#+begin_src conf :tangle ~/.config/polybar/config :mkdirp yes
  
  ; Docs: https://github.com/polybar/polybar
  ;==========================================================
  
  [settings]
  screenchange-reload = true
  
  [global/wm]
  margin-top = 0
  margin-bottom = 0
  
  [colors]
  background = ${colors.black}
  background-alt = ${xrdb:color0:#576075}
  foreground = #c03F1F
  foreground-alt = #555
  primary = #ffb52a
  secondary = #e60053
  alert = #bd2c40
  underline-1 = #c22F3F
  underline = #c79
  
  ; pywal polybar
  ; background = ${xrdb:color0:#222}
  ; background-alt = ${xrdb:color0:#222}
  ; foreground = ${xrdb:color7:#222}
  ; foreground-alt = ${xrdb:color7:#222}
  ; primary = ${xrdb:color1:#222}
  ; secondary = ${xrdb:color2:#222}
  ; alert = ${xrdb:color3:#222}
  ; underline-1=${xrdb:color0:#FFF}
  
  [bar/panel]
  width = 100%
  height = 25
  offset-x = 0
  offset-y = 0
  fixed-center = true
  enable-ipc = true
  
  background = ${colors.background}
  foreground = ${colors.foreground}
  
  line-size = 2
  line-color = #f00
  
  border-size = 0
  border-color = #000000
  
  padding-top = 5
  padding-left = 1
  padding-right = 20
  
  module-margin = 1.5
  
  font-0 = "Cantarell:size=18:weight=bold;2"
  font-1 = "Font Awesome:size=14;2"
  font-2 = "Material Icons:size=20;5"
  font-3 = "Fira Mono:size=13;-3"
  
  modules-left = exwm-workspace
  modules-right = cpu temperature battery date
  
  tray-position = right
  tray-padding = 2
  tray-maxsize = 28
  
  cursor-click = pointer
  cursor-scroll = ns-resize
  
  [module/exwm-workspace]
  type = custom/ipc
  hook-0 = emacsclient -e "exwm-workspace-current-index" | sed -e 's/^"//' -e 's/"$//'
  initial = 1
  format-underline = ${colors.underline-1}
  format-padding = 1
  
  [module/cpu]
  type = internal/cpu
  interval = 2
  format = Óå¢<label> <ramp-coreload>
  format-underline = ${colors.underline-1}
  click-left = emacsclient -e "(proced)"
  label = %percentage:2%%
  ramp-coreload-spacing = 0
  ramp-coreload-0 = ‚ñÅ
  ramp-coreload-0-foreground = ${colors.foreground-alt}
  ramp-coreload-1 = ‚ñÇ
  ramp-coreload-2 = ‚ñÉ
  ramp-coreload-3 = ‚ñÑ
  ramp-coreload-4 = ‚ñÖ
  ramp-coreload-5 = ‚ñÜ
  ramp-coreload-6 = ‚ñá
  
  [module/date]
  type = internal/date
  interval = 5
  
  date = "%a %b %e"
  date-alt = "%A %B %d %Y"
  
  time = %l:%M %p
  time-alt = %H:%M:%S
  
  format-prefix-foreground = ${colors.foreground-alt}
  format-underline = ${colors.underline-1}
  
  label = %date% %time%
  
  [module/battery]
  type = internal/battery
  battery = BAT0
  adapter = ADP1
  full-at = 98
  time-format = %-l:%M
  
  label-charging = %percentage%% / %time%
  format-charging = <animation-charging> <label-charging>
  format-charging-underline = ${colors.underline-1}
  
  label-discharging = %percentage%% / %time%
  format-discharging = <ramp-capacity> <label-discharging>
  format-discharging-underline = ${self.format-charging-underline}
  
  format-full = <ramp-capacity> <label-full>
  format-full-underline = ${self.format-charging-underline}
  
  ramp-capacity-0 = ÔâÑ
  ramp-capacity-1 = ÔâÉ
  ramp-capacity-2 = ÔâÇ
  ramp-capacity-3 = ÔâÅ
  ramp-capacity-4 = ÔâÄ
  
  animation-charging-0 = ÔâÑ
  animation-charging-1 = ÔâÉ
  animation-charging-2 = ÔâÇ
  animation-charging-3 = ÔâÅ
  animation-charging-4 = ÔâÄ
  animation-charging-framerate = 750
  
  [module/temperature]
  type = internal/temperature
  thermal-zone = 0
  warn-temperature = 60
  
  format = <label>
  format-underline = ${colors.underline-1}
  format-warn = <label-warn>
  format-warn-underline = ${self.format-underline}
  
  label = %temperature-c%
  label-warn = %temperature-c%!
  label-warn-foreground = ${colors.secondary}
  
#+end_src

*** The shortkey 
#+begin_src emacs-lisp
   (global-set-key (kbd "s-b") 'efs/start-panel)
   (global-set-key (kbd "C-x s-b") 'efs/kill-panel)
#+end_src

#+RESULTS:
: efs/kill-panel

** Desktop Notifications with Dunst

We use an application called [[https://dunst-project.org/][Dunst]] to enable the display of desktop notifications from Emacs and other applications running within EXWM.  Consult the [[https://dunst-project.org/documentation/][documentation]] for more details on how to configure this to your liking!

Here are some things you might want to consider changing:

- =format= - Customize how notification text contents are displayed
- =geometry= - Where the notification appears and how large it should be by default
- =urgency_normal=, etc - configures the background and frame color for notifications of different types
- =max_icon_size= - Constrain icon display since some icons will be larger than others
- =icon_path= - Important if your icons are not in a common location (like when using GNU Guix)
- =idle_threshold= - Wait for user to become active for this long before hiding notifications
- =mouse_left/right/middle_click= - Action to take when clicking a notification
- Any of the key bindings in the =shortcuts= section (though these are deprecated in 1.5.0, use =dunstctl=)

#+begin_src conf :tangle ~/.config/dunst/dunstrc :mkdirp yes

[global]
    ### Display ###
    monitor = 0

    # The geometry of the window:
    #   [{width}]x{height}[+/-{x}+/-{y}]
    geometry = "500x10-10+50"

    # Show how many messages are currently hidden (because of geometry).
    indicate_hidden = yes

    # Shrink window if it's smaller than the width.  Will be ignored if
    # width is 0.
    shrink = no

    # The transparency of the window.  Range: [0; 100].
    transparency = 10

    # The height of the entire notification.  If the height is smaller
    # than the font height and padding combined, it will be raised
    # to the font height and padding.
    notification_height = 0

    # Draw a line of "separator_height" pixel height between two
    # notifications.
    # Set to 0 to disable.
    separator_height = 1
    separator_color = frame

    # Padding between text and separator.
    padding = 8

    # Horizontal padding.
    horizontal_padding = 8

    # Defines width in pixels of frame around the notification window.
    # Set to 0 to disable.
    frame_width = 2

    # Defines color of the frame around the notification window.
    frame_color = "#89AAEB"

    # Sort messages by urgency.
    sort = yes

    # Don't remove messages, if the user is idle (no mouse or keyboard input)
    # for longer than idle_threshold seconds.
    idle_threshold = 120

    ### Text ###

    font = Cantarell 20

    # The spacing between lines.  If the height is smaller than the
    # font height, it will get raised to the font height.
    line_height = 0
    markup = full

    # The format of the message.  Possible variables are:
    #   %a  appname
    #   %s  summary
    #   %b  body
    #   %i  iconname (including its path)
    #   %I  iconname (without its path)
    #   %p  progress value if set ([  0%] to [100%]) or nothing
    #   %n  progress value if set without any extra characters
    #   %%  Literal %
    # Markup is allowed
    format = "<b>%s</b>\n%b"

    # Alignment of message text.
    # Possible values are "left", "center" and "right".
    alignment = left

    # Show age of message if message is older than show_age_threshold
    # seconds.
    # Set to -1 to disable.
    show_age_threshold = 60

    # Split notifications into multiple lines if they don't fit into
    # geometry.
    word_wrap = yes

    # When word_wrap is set to no, specify where to make an ellipsis in long lines.
    # Possible values are "start", "middle" and "end".
    ellipsize = middle

    # Ignore newlines '\n' in notifications.
    ignore_newline = no

    # Stack together notifications with the same content
    stack_duplicates = true

    # Hide the count of stacked notifications with the same content
    hide_duplicate_count = false

    # Display indicators for URLs (U) and actions (A).
    show_indicators = yes

    ### Icons ###

    # Align icons left/right/off
    icon_position = left

    # Scale larger icons down to this size, set to 0 to disable
    max_icon_size = 88

    # Paths to default icons.
    icon_path = /usr/share/icons/Adwaita/96x96/status:/usr/share/icons/Adwaita/96x96/emblems

    ### History ###

    # Should a notification popped up from history be sticky or timeout
    # as if it would normally do.
    sticky_history = no

    # Maximum amount of notifications kept in history
    history_length = 20

    ### Misc/Advanced ###

    # Browser for opening urls in context menu.
    browser = qutebrowser

    # Always run rule-defined scripts, even if the notification is suppressed
    always_run_script = true

    # Define the title of the windows spawned by dunst
    title = Dunst

    # Define the class of the windows spawned by dunst
    class = Dunst

    startup_notification = false
    verbosity = mesg

    # Define the corner radius of the notification window
    # in pixel size. If the radius is 0, you have no rounded
    # corners.
    # The radius will be automatically lowered if it exceeds half of the
    # notification height to avoid clipping text and/or icons.
    corner_radius = 4

    mouse_left_click = close_current
    mouse_middle_click = do_action
    mouse_right_click = close_all

# Experimental features that may or may not work correctly. Do not expect them
# to have a consistent behaviour across releases.
[experimental]
    # Calculate the dpi to use on a per-monitor basis.
    # If this setting is enabled the Xft.dpi value will be ignored and instead
    # dunst will attempt to calculate an appropriate dpi value for each monitor
    # using the resolution and physical size. This might be useful in setups
    # where there are multiple screens with very different dpi values.
    per_monitor_dpi = false

[shortcuts]

    # Shortcuts are specified as [modifier+][modifier+]...key
    # Available modifiers are "ctrl", "mod1" (the alt-key), "mod2",
    # "mod3" and "mod4" (windows-key).
    # Xev might be helpful to find names for keys.

    # Close notification.
    #close = ctrl+space

    # Close all notifications.
    #close_all = ctrl+shift+space

    # Redisplay last message(s).
    # On the US keyboard layout "grave" is normally above TAB and left
    # of "1". Make sure this key actually exists on your keyboard layout,
    # e.g. check output of 'xmodmap -pke'
    history = ctrl+grave

    # Context menu.
    context = ctrl+shift+period

[urgency_low]
    # IMPORTANT: colors have to be defined in quotation marks.
    # Otherwise the "#" and following would be interpreted as a comment.
    background = "#222222"
    foreground = "#888888"
    timeout = 10
    # Icon for notifications with low urgency, uncomment to enable
    #icon = /path/to/icon

[urgency_normal]
    background = "#1c1f26"
    foreground = "#ffffff"
    timeout = 10
    # Icon for notifications with normal urgency, uncomment to enable
    #icon = /path/to/icon

[urgency_critical]
    background = "#900000"
    foreground = "#ffffff"
    frame_color = "#ff0000"
    timeout = 0
    # Icon for notifications with critical urgency, uncomment to enable
    #icon = /path/to/icon

#+end_src

We can also set up some functions for enabling and disabling notifications at any time:

#+begin_src emacs-lisp

  (defun efs/disable-desktop-notifications ()
    (interactive)
    (start-process-shell-command "notify-send" nil "notify-send \"DUNST_COMMAND_PAUSE\""))

  (defun efs/enable-desktop-notifications ()
    (interactive)
    (start-process-shell-command "notify-send" nil "notify-send \"DUNST_COMMAND_RESUME\""))

  (defun efs/toggle-desktop-notifications ()
    (interactive)
    (start-process-shell-command "notify-send" nil "notify-send \"DUNST_COMMAND_TOGGLE\""))

#+end_src
* Applications
** IRC / ERC
  #+begin_src emacs-lisp
    (setq erc-server "irc.libera.chat"
	  erc-nick "buddhilw"
	  src-user-full-name "Litte White"
	  erc-track-shorten-start 8
	  erc-autojoin-channels-alist '(("irc-libera.chat" "#systemcrafters" "#emacs"))
	  erc-kill-buffer-on-part t
	  erc-auto-query 'bury)
  #+end_src

  #+RESULTS:
  : bury
** mu4e
#+begin_src emacs-lisp
  ;; (use-package mu4e)
  ;; (use-package evil-mu4e)
#+end_src 

*** Configuration
#+begin_src conf :tangle ~/.mbsyncrc
  IMAPAccount gmail
  Host imap.gmail.com
  User pedrogbranquinho@gmail.com
  PassCmd "cat ~/.emacs.d/.oh-no-insecure-password"
  SSLType IMAPS
  CertificateFile /etc/ssl/certs/ca-certificates.crt
  
  IMAPStore gmail-remote
  Account gmail
  
  MaildirStore gmail-local
  Subfolders Verbatim
  Path ~/Mail/
  Inbox ~/Mail/Inbox
  
  Channel gmail
  Master :gmail-remote:
  Slave :gmail-local:
  Patterns * ![Gmail]* "[Gmail]/Sent Mail" "[Gmail]/Starred" "[Gmail]/All Mail" "[Gmail]/Trash"
  Create Both
  SyncState *
#+end_src
 
#+begin_src emacs-lisp
  (use-package mu4e
  :ensure nil
  ;; :load-path "/usr/share/emacs/site-lisp/mu4e/"
  ;; :defer 20 ; Wait until 20 seconds after startup
  :config
  
  ;; This is set to 't' to avoid mail syncing issues when using mbsync
  (setq mu4e-change-filenames-when-moving t)
  
  ;; Refresh mail using isync every 10 minutes
  (setq mu4e-update-interval (* 10 60))
  (setq mu4e-get-mail-command "mbsync -a")
  (setq mu4e-maildir "~/Mail")
  
  (setq mu4e-drafts-folder "/[Gmail]/Drafts")
  (setq mu4e-sent-folder   "/[Gmail]/Sent Mail")
  (setq mu4e-refile-folder "/[Gmail]/All Mail")
  (setq mu4e-trash-folder  "/[Gmail]/Trash")
  
  (setq mu4e-maildir-shortcuts
    '((:maildir "/Inbox"    :key ?i)
      (:maildir "/[Gmail]/Sent Mail" :key ?s)
      (:maildir "/[Gmail]/Trash"     :key ?t)
      (:maildir "/[Gmail]/Drafts"    :key ?d)
      (:maildir "/[Gmail]/All Mail"  :key ?a))))
  
  ;; (use-package mu4e-alert)
#+end_src

#+RESULTS:
: t


#+begin_src emacs-lisp
  ;; (add-to-list 'load-path "~/yay/")
  ;; 
  ;; (require 'mu4e)
#+end_src

* Font config
** Fast Input methods

Copy pasta from [[https://stackoverflow.com/questions/12032231/is-it-possible-to-alternate-two-input-methods-in-emacs][Input Method Alternation]].
#+begin_src emacs-lisp
  ;; ;; Input method and key binding configuration.
  ;; (setq alternative-input-methods
  ;;       '(("chinese-tonepy" . [?\≈ì])
  ;;         '("chinese-sisheng"   . [?\¬∂])))
  
  ;; (setq default-input-method
  ;;       (caar alternative-input-methods))
  
  ;; (defun toggle-alternative-input-method (method &optional arg interactive)
  ;;   (if arg
  ;;       (toggle-input-method arg interactive)
  ;;     (let ((previous-input-method current-input-method))
  ;;       (when current-input-method
  ;;         (deactivate-input-method))
  ;;       (unless (and previous-input-method
  ;;                    (string= previous-input-method method))
  ;;         (activate-input-method method)))))
  
  ;; (defun reload-alternative-input-methods ()
  ;;   (dolist (config alternative-input-methods)
  ;;     (let ((method (car config)))
  ;;       (global-set-key (cdr config)
  ;;                       `(lambda (&optional arg interactive)
  ;;                          ,(concat "Behaves similar to `toggle-input-method', but uses \""
  ;;                                   method "\" instead of `default-input-method'")
  ;;                          (interactive "P\np")
  ;;                          (toggle-alternative-input-method ,method arg interactive))))))
  
  ;; (reload-alternative-input-methods)
#+end_src

#+RESULTS:
* EXWM setup
#+begin_src emacs-lisp
  (defun efs/exwm-update-class ()
    (exwm-workspace-rename-buffer exwm-class-name))

  (use-package exwm
    :config
    ;; Set the default number of workspaces
    (setq exwm-workspace-number 5)

    ;; When window "class" updates, use it to set the buffer name
    ;; (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)

    ;; These keys should always pass through to Emacs
    (setq exwm-input-prefix-keys
          '(?\C-x
            ?\C-u
            ?\C-h
            ?\M-x
            ?\M-`
            ?\M-&
            ?\M-:
            ?\C-\M-j  ;; Buffer list
            ?\C-\ ))  ;; Ctrl+Space

    ;; Ctrl+Q will enable the next key to be sent directly
    (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

    ;; Set up global key bindings.  These always work, no matter the input state!
    ;; Keep in mind that changing this list after EXWM initializes has no effect.
    (setq exwm-input-global-keys
          `(
            ;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
            ([?\s-r] . exwm-reset)

            ;; Move between windows
            ([s-left] . windmove-left)
            ([s-right] . windmove-right)
            ([s-up] . windmove-up)
            ([s-down] . windmove-down)

            ;; Launch applications via shell command
            ([?\s-&] . (lambda (command)
                         (interactive (list (read-shell-command "$ ")))
                         (start-process-shell-command command nil command)))

            ;; Switch workspace
            ([?\s-w] . exwm-workspace-switch)

            ;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
            ,@(mapcar (lambda (i)
                        `(,(kbd (format "s-%d" i)) .
                          (lambda ()
                            (interactive)
                            (exwm-workspace-switch-create ,i))))
                      (number-sequence 0 9))))

    (exwm-enable))
#+end_src

#+RESULTS:
: t

* Emacs Functionality
** Restarting Emacs

   #+begin_src emacs-lisp
     (use-package restart-emacs)
   #+end_src

* From LARBS to E-LARBS
** Bindings
*** remaps (script)
    
    #+begin_src shell :tangle ~/.local/bin/remaps
      #!/bin/sh
      
      # This script is called on startup to remap keys.
      # Increase key speed via a rate change
      xset r rate 300 50
      # Map the caps lock key to super...
      setxkbmap -option caps:super
      # But when it is pressed only once, treat it as escape.
      killall xcape 2>/dev/null ; xcape -e 'Super_L=Escape'
      # Map the menu button to right super as well.
      xmodmap -e 'keycode 135 = Super_R'
      # Turn off the caps lock if on since there is no longer a key for it.
      xset -q | grep "Caps Lock:\s*on" && xdotool key Caps_Lock
      
      # Set right alt as F12, to make dinamic bindings in emacs
      # clear F12
      # xmodmap -e 'keycode 108 = F12'
      # set 105 Control_R as 108 ISO_Level3_Shift
      # xmodmap -e 
      # -> put AltGr as meta in emacs
      # 108 ISO_Level3_Shift
      # xmodmap -e 'keycode 108 = '
    #+end_src

*** Window movement
    #+begin_src emacs-lisp
      ;; (global-set-key (kbd "s-l") 'enlarge-window-horizontally)
      (global-set-key (kbd "C-x s-b") 'efs/kill-panel)
    #+end_src

** .profile
   #+begin_src shell :tangle ~/.profile
     #!/bin/zsh
     
     # profile file. Runs on login. Environmental variables are set here.
     
     # If you don't plan on reverting to bash, you can remove the link in ~/.profile
     # to clean up.
     
     # Adds `~/.local/bin` to $PATH
     export PATH="$PATH:${$(find ~/.local/bin -type d -printf %p:)%%:}"
     
     unsetopt PROMPT_SP
     
     #Default programs:
     export EDITOR="emacs"
     export TERMINAL="st"
     export BROWSER="brave"
     
     # ~/ Clean-up:
     export XDG_CONFIG_HOME="$HOME/.config"
     export XDG_DATA_HOME="$HOME/.local/share"
     export XDG_CACHE_HOME="$HOME/.cache"
     export XINITRC="${XDG_CONFIG_HOME:-$HOME/.config}/x11/xinitrc"
     export XAUTHORITY="$XDG_RUNTIME_DIR/Xauthority" # This line will break some DMs.
     export NOTMUCH_CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}/notmuch-config"
     export GTK2_RC_FILES="${XDG_CONFIG_HOME:-$HOME/.config}/gtk-2.0/gtkrc-2.0"
     export LESSHISTFILE="-"
     export WGETRC="${XDG_CONFIG_HOME:-$HOME/.config}/wget/wgetrc"
     export INPUTRC="${XDG_CONFIG_HOME:-$HOME/.config}/shell/inputrc"
     export ZDOTDIR="${XDG_CONFIG_HOME:-$HOME/.config}/zsh"
     #export ALSA_CONFIG_PATH="$XDG_CONFIG_HOME/alsa/asoundrc"
     #export GNUPGHOME="${XDG_DATA_HOME:-$HOME/.local/share}/gnupg"
     export WINEPREFIX="${XDG_DATA_HOME:-$HOME/.local/share}/wineprefixes/default"
     export KODI_DATA="${XDG_DATA_HOME:-$HOME/.local/share}/kodi"
     export PASSWORD_STORE_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/password-store"
     export TMUX_TMPDIR="$XDG_RUNTIME_DIR"
     export ANDROID_SDK_HOME="${XDG_CONFIG_HOME:-$HOME/.config}/android"
     export CARGO_HOME="${XDG_DATA_HOME:-$HOME/.local/share}/cargo"
     export GOPATH="${XDG_DATA_HOME:-$HOME/.local/share}/go"
     export ANSIBLE_CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}/ansible/ansible.cfg"
     export UNISON="${XDG_DATA_HOME:-$HOME/.local/share}/unison"
     export HISTFILE="${XDG_DATA_HOME:-$HOME/.local/share}/history"
     export WEECHAT_HOME="${XDG_CONFIG_HOME:-$HOME/.config}/weechat"
     
     # Other program settings:
     export DICS="/usr/share/stardict/dic/"
     export SUDO_ASKPASS="$HOME/.local/bin/dmenupass"
     export FZF_DEFAULT_OPTS="--layout=reverse --height 40%"
     export LESS=-R
     export LESS_TERMCAP_mb="$(printf '%b' '[1;31m')"
     export LESS_TERMCAP_md="$(printf '%b' '[1;36m')"
     export LESS_TERMCAP_me="$(printf '%b' '[0m')"
     export LESS_TERMCAP_so="$(printf '%b' '[01;44;33m')"
     export LESS_TERMCAP_se="$(printf '%b' '[0m')"
     export LESS_TERMCAP_us="$(printf '%b' '[1;32m')"
     export LESS_TERMCAP_ue="$(printf '%b' '[0m')"
     export LESSOPEN="| /usr/bin/highlight -O ansi %s 2>/dev/null"
     export QT_QPA_PLATFORMTHEME="gtk2"	# Have QT use gtk2 theme.
     export MOZ_USE_XINPUT2="1"		# Mozilla smooth scrolling/touchpads.
     export AWT_TOOLKIT="MToolkit wmname LG3D"	#May have to install wmname
     export _JAVA_AWT_WM_NONREPARENTING=1	# Fix for Java applications in dwm
     
     # This is the list for lf icons:
     export LF_ICONS="di=üìÅ:\
     fi=üìÉ:\
     tw=ü§ù:\
     ow=üìÇ:\
     ln=‚õì:\
     or=‚ùå:\
     ex=üéØ:\
     ,*.txt=‚úç:\
     ,*.mom=‚úç:\
     ,*.me=‚úç:\
     ,*.ms=‚úç:\
     ,*.png=üñº:\
     ,*.webp=üñº:\
     ,*.ico=üñº:\
     ,*.jpg=üì∏:\
     ,*.jpe=üì∏:\
     ,*.jpeg=üì∏:\
     ,*.gif=üñº:\
     ,*.svg=üó∫:\
     ,*.tif=üñº:\
     ,*.tiff=üñº:\
     ,*.xcf=üñå:\
     ,*.html=üåé:\
     ,*.xml=üì∞:\
     ,*.gpg=üîí:\
     ,*.css=üé®:\
     ,*.pdf=üìö:\
     ,*.djvu=üìö:\
     ,*.epub=üìö:\
     ,*.csv=üìì:\
     ,*.xlsx=üìì:\
     ,*.tex=üìú:\
     ,*.md=üìò:\
     ,*.r=üìä:\
     ,*.R=üìä:\
     ,*.rmd=üìä:\
     ,*.Rmd=üìä:\
     ,*.m=üìä:\
     ,*.mp3=üéµ:\
     ,*.opus=üéµ:\
     ,*.ogg=üéµ:\
     ,*.m4a=üéµ:\
     ,*.flac=üéº:\
     ,*.wav=üéº:\
     ,*.mkv=üé•:\
     ,*.mp4=üé•:\
     ,*.webm=üé•:\
     ,*.mpeg=üé•:\
     ,*.avi=üé•:\
     ,*.mov=üé•:\
     ,*.mpg=üé•:\
     ,*.wmv=üé•:\
     ,*.m4b=üé•:\
     ,*.flv=üé•:\
     ,*.zip=üì¶:\
     ,*.rar=üì¶:\
     ,*.7z=üì¶:\
     ,*.tar.gz=üì¶:\
     ,*.z64=üéÆ:\
     ,*.v64=üéÆ:\
     ,*.n64=üéÆ:\
     ,*.gba=üéÆ:\
     ,*.nes=üéÆ:\
     ,*.gdi=üéÆ:\
     ,*.1=‚Ñπ:\
     ,*.nfo=‚Ñπ:\
     ,*.info=‚Ñπ:\
     ,*.log=üìô:\
     ,*.iso=üìÄ:\
     ,*.img=üìÄ:\
     ,*.bib=üéì:\
     ,*.ged=üë™:\
     ,*.part=üíî:\
     ,*.torrent=üîΩ:\
     ,*.jar=‚ô®:\
     ,*.java=‚ô®:\
     "
     
     [ ! -f ${XDG_CONFIG_HOME:-$HOME/.config}/shell/shortcutrc ] && shortcuts >/dev/null 2>&1 &
     
     if pacman -Qs libxft-bgra >/dev/null 2>&1; then
	 # Start graphical server on user's current tty if not already running.
	 [ "$(tty)" = "/dev/tty1" ] && ! pidof -s Xorg >/dev/null 2>&1 && exec startx
     else
	 echo "\033[31mIMPORTANT\033[0m: Note that \033[32m\`libxft-bgra\`\033[0m must be installed for this build of dwm.
     Please run:
	     \033[32myay -S libxft-bgra-git\033[0m
     and replace \`libxft\`. Afterwards, you may start the graphical server by running \`startx\`."
     fi
     
     # Switch escape and caps if tty and no passwd required:
     sudo -n loadkeys ${XDG_DATA_HOME:-$HOME/.local/share}/larbs/ttymaps.kmap 2>/dev/null
     
   #+end_src

   #+begin_src emacs-lisp
     (use-package evil-multiedit
       :hook (web-mode . evil-multiedit-mode))
   #+end_src

   # evil multiedit
   # multiple-cursors
** Brazilian Keyboard Layout
In Artix (runit)
#+begin_src conf :tangle "/sudo::/etc/vconsole.conf"
KEYMAP=br-latin1-us
#+end_src
** Galery viewing
   # #+begin_src emacs-lisp
   #   (use-package )
   #   #+end_src
** Calendar
   #+begin_src emacs-lisp
     (use-package calendar
       :config
       (require 'generic)
       (define-generic-mode 'fancy-diary-display-mode
	 nil
	 (list "Exception" "Location" "Desc")
	 '(
	   ("\\(.*\\)\n\\(=+\\)"            ;; Day title / separator lines
	    (1 'font-lock-keyword-face) (2 'font-lock-preprocessor-face))
	   ("^\\(todo [^:]*:\\)\\(.*\\)$"   ;; To do entries
	    (1 'font-lock-string-face) (2 'font-lock-reference-face))
	   ("\\(\\[.*\\]\\)"                ;; Category labels
	    1 'font-lock-constant-face)
	   ("^\\(0?\\([1-9][0-9]?:[0-9][0-9]\\)\\([ap]m\\)?\\(-0?\\([1-9][0-9]?:[0-9][0-9]\\)\\([ap]m\\)?\\)?\\)"
	    1 'font-lock-type-face))        ;; Time intervals at start of lines.
	 nil
	 (list
	  (function
	   (lambda ()
	     (turn-on-font-lock))))
	 "Mode for fancy diary display."))
   #+end_src

   #+RESULTS:
   : t
** Zsh config
#+begin_src conf :tangle ~/.config/zsh/.zshrc
  # Buddhi's config for the ZSH. pedrogbranquinho@gmail.com 
      # üÖ≠üÖØüÑè üÖ≠ 
  
  # Enable colors and change prompt:
  autoload -U colors && colors	# Load colors
  PS1="%B%{$fg[blue]%}(%{$fg[yellow]%}%n %B%{$fg[red]%}'(%{$fg[magenta]%}%~%{$fg[red]%})%{$fg[blue]%})%{$fg[cyan]%} Œª%b "
  setopt autocd		# Automatically cd into typed directory.
  stty stop undef		# Disable ctrl-s to freeze terminal.
  setopt interactive_comments
  
  # History in cache directory:
  HISTSIZE=10000000
  SAVEHIST=10000000
  HISTFILE=~/.cache/zsh/history
  
  # Load aliases and shortcuts if existent.
  [ -f "${XDG_CONFIG_HOME:-$HOME/.config}/shell/shortcutrc" ] && source "${XDG_CONFIG_HOME:-$HOME/.config}/shell/shortcutrc"
  [ -f "${XDG_CONFIG_HOME:-$HOME/.config}/shell/aliasrc" ] && source "${XDG_CONFIG_HOME:-$HOME/.config}/shell/aliasrc"
  [ -f "${XDG_CONFIG_HOME:-$HOME/.config}/shell/zshnameddirrc" ] && source "${XDG_CONFIG_HOME:-$HOME/.config}/shell/zshnameddirrc"
  
  # Basic auto/tab complete:
  autoload -U compinit
  zstyle ':completion:*' menu select
  zmodload zsh/complist
  compinit
  _comp_options+=(globdots)		# Include hidden files.
  
  # vi mode
  bindkey -v
  export KEYTIMEOUT=1
  
  # Use vim keys in tab complete menu:
  bindkey -M menuselect 'h' vi-backward-char
  bindkey -M menuselect 'k' vi-up-line-or-history
  bindkey -M menuselect 'l' vi-forward-char
  bindkey -M menuselect 'j' vi-down-line-or-history
  bindkey -v '^?' backward-delete-char
  
  # Change cursor shape for different vi modes.
  function zle-keymap-select () {
      case $KEYMAP in
          vicmd) echo -ne '\e[1 q';;      # block
          viins|main) echo -ne '\e[5 q';; # beam
      esac
  }
  zle -N zle-keymap-select
  zle-line-init() {
      zle -K viins # initiate `vi insert` as keymap (can be removed if `bindkey -V` has been set elsewhere)
      echo -ne "\e[5 q"
  }
  zle -N zle-line-init
  echo -ne '\e[5 q' # Use beam shape cursor on startup.
  preexec() { echo -ne '\e[5 q' ;} # Use beam shape cursor for each new prompt.
  
  # Use lf to switch directories and bind it to ctrl-o
  lfcd () {
      tmp="$(mktemp)"
      lf -last-dir-path="$tmp" "$@"
      if [ -f "$tmp" ]; then
          dir="$(cat "$tmp")"
          rm -f "$tmp" >/dev/null
          [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && cd "$dir"
      fi
  }
  bindkey -s '^o' 'lfcd\n'
  
  bindkey -s '^a' 'bc -lq\n'
  
  bindkey -s '^f' 'cd "$(dirname "$(fzf)")"\n'
  
  bindkey '^[[P' delete-char
  
  # Edit line in vim with ctrl-e:
  autoload edit-command-line; zle -N edit-command-line
  bindkey '^e' edit-command-line
  
  # Load syntax highlighting; should be last.
  source /usr/share/zsh/plugins/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh 2>/dev/null
#+end_src
** Unicode characters
#+begin_src emacs-lisp
(use-package unicode-fonts
   :ensure t
   :config
    (unicode-fonts-setup))
    #+end_src

#+begin_src emacs-lisp
 (use-package dynamic-fonts)
  #+end_src

  #+RESULTS:

  #+begin_src emacs-lisp
    (use-package ucs-utils)
    #+end_src

    #+RESULTS:
  
* Powerline
  #+begin_src emacs-lisp
    ;; (use-package powerline
      ;; :ensure
      ;; :init
      ;; (powerline-evil-theme))
    (require 'powerline)
    (powerline-center-evil-theme)
    #+end_src

