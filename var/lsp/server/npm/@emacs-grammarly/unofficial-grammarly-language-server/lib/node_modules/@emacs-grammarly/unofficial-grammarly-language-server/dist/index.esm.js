import 'reflect-metadata';
import { injectable, inject, Container } from 'inversify';
import { DiagnosticSeverity, Disposable, TextDocuments, TextDocumentSyncKind, CodeActionKind, DiagnosticTag, createConnection, ProposedFeatures } from 'vscode-languageserver';
import minimatch from 'minimatch';
import { TextDocument } from 'vscode-languageserver-textdocument';
import remark from 'remark';
import IntervalTree from '@flatten-js/interval-tree';
import { getIdRevision, GrammarlyClient, SocketError, ResponseKind, ChangeSet, SocketErrorCode, anonymous, authenticate, applyDelta } from '@emacs-grammarly/unofficial-grammarly-api';
import { inspect } from 'util';
import { ref, markRaw, stop, effect, isRef } from '@vue/reactivity';
import { EventEmitter } from 'events';

const CLIENT = Symbol('ClientCapabilities');
const CLIENT_INFO = Symbol('ClientInfo');
const SERVER = Symbol('ServerCapabilities');
const CONNECTION = Symbol('Connection');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

const DEFAULT = {
    /** Extension Config */
    autoActivate: true,
    ignore: [],
    severity: {
        Determiners: DiagnosticSeverity.Error,
        Misspelled: DiagnosticSeverity.Error,
        Unknown: DiagnosticSeverity.Error,
        ClosingPunct: DiagnosticSeverity.Error,
        Nouns: DiagnosticSeverity.Error,
        OddWords: DiagnosticSeverity.Warning,
        CompPunct: DiagnosticSeverity.Warning,
        Clarity: DiagnosticSeverity.Warning,
        Dialects: DiagnosticSeverity.Warning,
        WordChoice: DiagnosticSeverity.Information,
        Readability: DiagnosticSeverity.Information,
        PassiveVoice: DiagnosticSeverity.Hint,
        _default: DiagnosticSeverity.Hint,
    },
    userWords: [],
    diagnostics: {
        '[markdown]': {
            ignore: ['code'],
        },
        '[mdx]': {
            ignore: ['code'],
        },
    },
    /** Grammarly Config */
    audience: 'knowledgeable',
    dialect: 'american',
    domain: 'general',
    emotions: [],
    goals: [],
    style: 'neutral',
    /** Grammarly Document Config */
    overrides: [],
    /** Internal */
    debug: false,
    showUsernameInStatusBar: true,
    showDeletedTextInQuickFix: true,
    showExplanation: true,
    showExamples: false,
    hideUnavailablePremiumAlerts: false,
};

function toArray(item) {
    if (!item)
        return [];
    else if (Array.isArray(item))
        return item;
    else
        return [item];
}

let ConfigurationService = class ConfigurationService {
    constructor(connection) {
        this.connection = connection;
        this.default = DEFAULT;
        this.user = this.default;
        this.perDocumentSettings = new Map();
        this.wip = new Map();
    }
    get settings() {
        return this.user;
    }
    register() {
        this.connection.onDidChangeConfiguration(({ settings }) => {
            if ('grammarly' in settings) {
                this.user = {
                    ...this.default,
                    ...settings.grammarly,
                };
                this.perDocumentSettings.clear();
                this.wip.clear();
            }
        });
        setTimeout(() => {
            this.connection.workspace.getConfiguration('grammarly').then((settings) => {
                this.user = {
                    ...this.default,
                    ...settings,
                };
            });
        }, 0);
        return Disposable.create(() => {
            this.wip.clear();
            this.perDocumentSettings.clear();
        });
    }
    async getAlertSeverity(uri) {
        const config = await this.connection.workspace.getConfiguration({
            scopeUri: uri,
            section: 'grammarly',
        });
        return {
            ...this.default.severity,
            ...config === null || config === void 0 ? void 0 : config.severity,
        };
    }
    async getIgnoredTags(uri, languageId) {
        var _a;
        const config = await this.connection.workspace.getConfiguration({
            scopeUri: uri,
            section: 'grammarly',
        });
        return ((_a = config.diagnostics[`[${languageId}]`]) === null || _a === void 0 ? void 0 : _a.ignore) || [];
    }
    getDocumentSettings(uri, fresh = false) {
        if (this.perDocumentSettings.has(uri) && fresh === false) {
            return this.perDocumentSettings.get(uri);
        }
        if (this.wip.has(uri)) {
            return this.wip.get(uri);
        }
        const get = async () => {
            const config = {
                ...this.user,
                ...(await this.connection.workspace.getConfiguration({
                    scopeUri: uri,
                    section: 'grammarly',
                })),
            };
            const override = config.overrides.find((override) => toArray(override.files).some((pattern) => minimatch(uri, pattern)));
            const settings = {
                audience: config.audience,
                dialect: config.dialect,
                domain: config.domain,
                emotions: config.emotions,
                goals: config.goals,
                style: config.style,
                ...override === null || override === void 0 ? void 0 : override.config,
            };
            this.perDocumentSettings.set(uri, settings);
            this.wip.delete(uri);
            return settings;
        };
        const promise = get();
        this.wip.set(uri, promise);
        return promise;
    }
    isIgnoredDocument(uri) {
        return toArray(this.user.ignore).some((pattern) => minimatch(uri, pattern));
    }
};
ConfigurationService = __decorate([
    injectable(),
    __param(0, inject(CONNECTION)),
    __metadata("design:paramtypes", [Object])
], ConfigurationService);

let DictionaryService = class DictionaryService {
    constructor(configuration) {
        this.configuration = configuration;
    }
    register() {
        return Disposable.create(() => { });
    }
    isKnownWord(word) {
        const words = this.configuration.settings.userWords;
        return words.includes(word) || words.includes(word.toLocaleLowerCase());
    }
};
DictionaryService = __decorate([
    injectable(),
    __metadata("design:paramtypes", [ConfigurationService])
], DictionaryService);

const parser = remark();
function parse(content) {
    const ast = parser.parse(content);
    const tree = new IntervalTree();
    iterate(ast, node => {
        const { type, position } = node;
        if (position) {
            tree.insert([position.start.offset, position.end.offset], type);
        }
    });
    return (interval) => tree.search(interval);
}
function iterate(node, fn) {
    const queue = [node];
    fn(node);
    while (queue.length) {
        const node = queue.shift();
        node.children.forEach(node => {
            fn(node);
            if (Array.isArray(node.children)) {
                queue.push(node);
            }
        });
    }
}

var markdown = /*#__PURE__*/Object.freeze({
    __proto__: null,
    parse: parse
});

const parsers = {
    markdown,
};

class GrammarlyDocument {
    constructor(internal) {
        this.internal = internal;
        this._host = null;
        this.isDirty = true;
    }
    attachHost(factory, clientInfo) {
        this.detachHost();
        this._host = factory.create(this, clientInfo);
    }
    detachHost() {
        if (this._host) {
            this._host.dispose();
            this._host = null;
        }
    }
    inIgnoredRange(interval, tags) {
        if (this.isDirty) {
            this.isDirty = false;
            const parser = parsers[this.languageId];
            try {
                if (parser)
                    this.rangeToIdentifierFn = parser.parse(this.getText());
            }
            catch { }
        }
        if (this.rangeToIdentifierFn) {
            const matched = new Set(this.rangeToIdentifierFn(interval));
            return tags.some((tag) => matched.has(tag));
        }
        return false;
    }
    get host() {
        return this._host;
    }
    get uri() {
        return this.internal.uri;
    }
    get languageId() {
        return this.internal.languageId;
    }
    get version() {
        return this.internal.version;
    }
    getText(range) {
        return this.internal.getText(range);
    }
    positionAt(offset) {
        return this.internal.positionAt(offset);
    }
    rangeAt(start, end) {
        return { start: this.positionAt(start), end: this.positionAt(end) };
    }
    offsetAt(position) {
        return this.internal.offsetAt(position);
    }
    get lineCount() {
        return this.internal.lineCount;
    }
    static create(uri, languageId, version, content) {
        return new GrammarlyDocument(TextDocument.create(uri, languageId, version, content));
    }
    static update(document, changes, version) {
        document.isDirty = true;
        document.internal = TextDocument.update(document.internal, changes, version);
        if (document._host) {
            document._host.setText(document.getText());
        }
        return document;
    }
}

const displayLevel = {
    [0 /* TRACE */]: 'TRACE',
    [1 /* DEBUG */]: 'DEBUG',
    [2 /* INFO */]: 'INFO',
    [3 /* WARN */]: 'WARN',
    [4 /* ERROR */]: 'ERROR',
    [5 /* NONE */]: 'NONE',
};
function isString(value) {
    return typeof value === 'string';
}
function isError(value) {
    return value instanceof Error;
}
class Logger {
    constructor(name, defaultContext = '') {
        this.name = name;
        this.defaultContext = defaultContext;
    }
    trace(...args) {
        this.write(0 /* TRACE */, args);
    }
    debug(...args) {
        this.write(1 /* DEBUG */, args);
    }
    info(...args) {
        this.write(2 /* INFO */, args);
    }
    warn(...args) {
        this.write(3 /* WARN */, args);
    }
    error(...args) {
        this.write(4 /* ERROR */, args);
    }
    write(level, args) {
        if (level >= Logger.options.level &&
            (Logger.options.enabled.has('*') || Logger.options.enabled.has(this.name))) {
            const context = args.length >= 2 && isString(args[0]) && (isString(args[1]) || isError(args[1]))
                ? args.shift()
                : this.defaultContext;
            const message = `${Date.now()} ${displayLevel[level]}  [${this.name}]${context ? ' (' + context + ')' : ''} ${this.inspect(args)}`;
            switch (level) {
                case 4 /* ERROR */:
                    console.error(message);
                    break;
                case 3 /* WARN */:
                    console.warn(message);
                    break;
                default:
                    console.log(message);
                    break;
            }
        }
    }
    inspect(args) {
        return args.map((arg) => (typeof arg === 'object' && arg ? inspect(arg, true, null) : arg)).join(' ');
    }
}
Logger.options = {
    enabled: new Set(['*']),
    level: 1 /* DEBUG */,
};
class DevLogger extends Logger {
}

function parseClientName(name) {
    if (name.includes(':')) {
        const parts = name.split(':');
        return { name: parts[0], type: parts[1] };
    }
    return { name, type: 'general' };
}
class TextGrammarCheckHost {
    constructor(clientInfo, document, getDocumentContext, getTokenInfo, onError) {
        var _a, _b;
        this.clientInfo = clientInfo;
        this.document = document;
        this.getDocumentContext = getDocumentContext;
        this.getTokenInfo = getTokenInfo;
        this.onError = onError;
        this.events = new EventEmitter({ captureRejections: true });
        this.auth = null;
        this.revision = getIdRevision(-1);
        this.localText = '';
        this.remoteText = '';
        this.alerts = ref(new Map());
        this.user = ref({ isAnonymous: true, isPremium: false, username: 'anonymous' });
        this.score = ref(-1);
        this.generalScore = ref(-1);
        this.status = ref('CHECKING');
        this.scores = ref({});
        this.emotions = ref([]);
        this.textInfo = ref(null);
        this.disposables = [];
        this.isSyncing = false;
        this.id = Buffer.from(this.document.uri).toString('hex');
        this.LOGGER = process.env.NODE_ENV !== 'production' ? new DevLogger(TextGrammarCheckHost.name, this.id.substr(0, 6)) : null;
        const { name, type } = parseClientName((_a = this.clientInfo.name) !== null && _a !== void 0 ? _a : '@emacs-grammarly/unofficial-grammarly-language-server');
        this.api = new GrammarlyClient({
            clientName: name,
            clientType: type,
            clientVersion: this.clientInfo.version,
            documentId: this.id,
            getToken: async () => {
                var _a;
                this.auth = await this.getTokenInfo();
                if (this.auth != null) {
                    this.user.value = {
                        username: this.auth.username,
                        isAnonymous: this.auth.isAnonymous,
                        isPremium: (_a = this.auth.isPremium) !== null && _a !== void 0 ? _a : false,
                    };
                }
                return this.auth.token;
            },
            onConnection: async () => {
                const context = await this.getDocumentContext();
                await this.api.start({ documentContext: context, dialect: context.dialect });
                await this.api.setOption({
                    name: 'gnar_containerId',
                    value: this.auth.container,
                });
                this.setText(this.document.getText());
            },
            onMessage: (message) => this.events.emit(message.action, message),
            onError: (error) => {
                this.onError(error);
                if (error instanceof SocketError) {
                    if (error.code === 4000) {
                        this.api.ping();
                    }
                }
            },
        });
        if (process.env.NODE_ENV !== 'production')
            (_b = this.LOGGER) === null || _b === void 0 ? void 0 : _b.debug(`Hosting ${document.uri}`);
        this.on(ResponseKind.ALERT, (alert) => {
            var _a;
            const changeset = new ChangeSet(this.remoteText, this.localText);
            const newAlert = this.reposition(alert, changeset);
            if (process.env.NODE_ENV !== 'production')
                (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace(`New alert(${alert.rev}) ${alert.id}: ${alert.highlightBegin} -> ${newAlert.highlightBegin}`);
            this.alerts.value.set(alert.id, markRaw({ ...newAlert, raw: alert }));
        });
        this.on(ResponseKind.REMOVE, (alert) => this.alerts.value.delete(alert.id));
        this.on(ResponseKind.EMOTIONS, (message) => {
            this.emotions.value = message.emotions;
        });
        this.on(ResponseKind.FINISHED, (message) => {
            this.status.value = 'IDLE';
            if (message.outcomeScores) {
                this.scores.value = message.outcomeScores;
            }
            this.score.value = message.score;
            if (message.generalScore) {
                this.generalScore.value = message.generalScore;
            }
        });
        this.on(ResponseKind.TEXT_INFO, (message) => {
            this.textInfo.value = message;
        });
        this.on(ResponseKind.TEXT_INFO, (message) => {
            this.textInfo.value = message;
        });
    }
    get context() {
        return this.auth || { username: 'anonymous', isAnonymous: true, container: '' };
    }
    on(action, callback) {
        this.events.on(action, callback);
        return () => this.off(action, callback);
    }
    off(action, callback) {
        this.events.off(action, callback);
    }
    once(action, callback) {
        this.events.once(action, callback);
    }
    onDispose(fn) {
        this.disposables.push(fn);
    }
    dispose() {
        this.disposables.forEach((dispose) => {
            try {
                dispose();
            }
            catch { }
        });
        this.api.dispose();
        this.events.removeAllListeners();
    }
    setText(text) {
        this.repositionAlerts(new ChangeSet(this.localText, text));
        this.localText = text;
        void this.sync();
    }
    repositionAlerts(changeset) {
        var _a;
        const newAlerts = new Map();
        if (process.env.NODE_ENV !== 'production')
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.debug('ChangeSet', changeset.diff());
        this.alerts.value.forEach((alert) => {
            var _a;
            const newAlert = this.reposition(alert, changeset);
            if (newAlert.highlightBegin !== alert.highlightBegin) {
                if (process.env.NODE_ENV !== 'production')
                    (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace(`Repositioned(${alert.rev}) ${newAlert.id}: ${alert.highlightBegin} -> ${newAlert.highlightBegin}, ${alert.highlightEnd} -> ${newAlert.highlightEnd}`);
            }
            newAlerts.set(newAlert.id, markRaw({ ...newAlert, raw: alert.raw }));
        });
        this.alerts.value = newAlerts;
    }
    reposition(alert, changeset) {
        var _a;
        if (alert.highlightBegin != null) {
            const highlightLen = alert.highlightEnd - alert.highlightBegin;
            alert.highlightBegin = changeset.reposition(alert.highlightBegin);
            alert.highlightEnd = alert.highlightBegin + highlightLen;
        }
        if (alert.begin != null) {
            const len = alert.end - alert.begin;
            alert.begin = changeset.reposition(alert.begin);
            alert.end = alert.begin + len;
        }
        (_a = alert.subalerts) === null || _a === void 0 ? void 0 : _a.forEach(subalert => {
            if (subalert.transformJson.context.s != null) {
                const len = subalert.transformJson.context.e - subalert.transformJson.context.s;
                subalert.transformJson.context.s = changeset.reposition(subalert.transformJson.context.s);
                subalert.transformJson.context.e = subalert.transformJson.context.s + len;
            }
        });
        return alert;
    }
    async sync() {
        var _a, _b, _c;
        if (this.isSyncing) {
            (_a = this.LOGGER) === null || _a === void 0 ? void 0 : _a.trace('[sync] another sync request in progress, skipping...');
            return;
        }
        if (this.remoteText === this.localText) {
            (_b = this.LOGGER) === null || _b === void 0 ? void 0 : _b.trace(`[sync] No text change, skipping...`);
            return;
        }
        this.isSyncing = true;
        const remoteText = this.remoteText;
        const localText = this.localText;
        const changeset = new ChangeSet(remoteText, localText);
        const deltas = changeset.diff();
        const rev = getIdRevision(this.revision + 1);
        this.remoteText = localText;
        this.revision = rev;
        await this.api.submitOT({ rev, doc_len: remoteText.length, deltas, chunked: false });
        this.isSyncing = false;
        (_c = this.LOGGER) === null || _c === void 0 ? void 0 : _c.debug(`[sync] Remote Text: ${rev}`);
        void this.sync();
    }
    async getSynonyms(offset, word) {
        const result = await this.api.getSynonyms({ begin: offset, token: word });
        return result.synonyms.meanings;
    }
    async getTextStats() {
        return this.api.getTextStats({});
    }
    getAlert(id) {
        return this.alerts.value.get(id);
    }
    async addToDictionary(alertId) {
        await this.api.sendFeedbackForAlert({ type: 'ADD_TO_DICTIONARY', alertId });
    }
    async dismissAlert(alertId) {
        this.alerts.value.delete(alertId);
        await this.api.sendFeedbackForAlert({ type: 'IGNORE', alertId });
    }
    async acceptAlert(alertId, text) {
        this.alerts.value.delete(alertId);
        await this.api.sendFeedbackForAlert({ type: 'ACCEPTED', text, alertId });
    }
    async setDocumentContext(documentContext) {
        await this.api.setContext({ rev: this.revision, documentContext });
    }
}

var version = "0.2.0";

const knownClients = {
    'vscode': {
        name: 'extension_vscode',
        type: 'general',
        version: version
    },
    'vscode-insiders': {
        name: 'extension_vscode',
        type: 'insiders',
        version: version
    },
};
class GrammarlyHostFactory {
    constructor(getDocumentContext, getCredentials, storeToken) {
        this.getDocumentContext = getDocumentContext;
        this.getCredentials = getCredentials;
        this.storeToken = storeToken;
        this.LOGGER = new DevLogger(GrammarlyHostFactory.name);
        this.auth = null;
    }
    create(document, clientInfo) {
        var _a;
        const host = new TextGrammarCheckHost((_a = knownClients[clientInfo.name]) !== null && _a !== void 0 ? _a : clientInfo, document, () => this.getDocumentContext(document), () => this.getAuth(), (error) => {
            if (error instanceof SocketError) {
                if (error.code === SocketErrorCode.UNAUTHORIZED) {
                    this.auth = null;
                    // @ts-ignore - accessing private property.
                    host.api.reconnect();
                }
            }
        });
        return host;
    }
    async getAuth() {
        if (!this.auth) {
            try {
                this.auth = await this.asUser();
            }
            catch (error) {
                console.error(error);
            }
        }
        return this.auth || this.asAnonymous();
    }
    async asAnonymous() {
        return (this.auth = await anonymous());
    }
    async asUser() {
        const credentials = await this.getCredentials();
        if (typeof credentials === 'string') {
            return JSON.parse(credentials);
        }
        else if (credentials) {
            this.auth = await authenticate(credentials.username, credentials.password);
            if (this.auth)
                this.storeToken(JSON.stringify(this.auth));
        }
    }
}

var GrammarlyLanguageServer;
(function (GrammarlyLanguageServer) {
    GrammarlyLanguageServer.Feature = {
        stop: '$/stop',
        checkGrammar: '$/checkGrammar',
        acceptAlert: '$/feedbackAcceptAlert',
        dismissAlert: '$/feedbackDismissAlert',
        addToDictionary: '$/feedbackAddToDictionary',
        getDocumentState: '$/getDocumentState',
    };
    (function (Client) {
        Client.Feature = {
            getCredentials: '$/getCredentials',
            getToken: '$/getToken',
            storeToken: '$/storeToken',
            showError: '$/showError',
            updateDocumentState: '$/updateDocumentState',
        };
    })(GrammarlyLanguageServer.Client || (GrammarlyLanguageServer.Client = {}));
})(GrammarlyLanguageServer || (GrammarlyLanguageServer = {}));

var DocumentService_1;
let DocumentService = DocumentService_1 = class DocumentService {
    constructor(connection, capabilities, client, configuration) {
        this.connection = connection;
        this.capabilities = capabilities;
        this.client = client;
        this.configuration = configuration;
        this.LOGGER = new DevLogger(DocumentService_1.name);
        this.documents = new TextDocuments(GrammarlyDocument);
        this.hostFactory = new GrammarlyHostFactory(async (document) => this.configuration.getDocumentSettings(document.uri), async () => this.getCredentials(), async (token) => this.connection.sendRequest(GrammarlyLanguageServer.Client.Feature.storeToken, { token }));
        this.onDocumentOpenCbs = [];
        this.onDocumentCloseCbs = [];
    }
    register() {
        this.capabilities.textDocumentSync = {
            openClose: true,
            change: TextDocumentSyncKind.Incremental,
        };
        this.documents.listen(this.connection);
        const disposables = [
            this.documents.onDidOpen(({ document }) => this.attachHost(document)),
            this.documents.onDidClose(({ document }) => this.handleClose(document)),
            Disposable.create(() => this.documents.all().forEach((document) => document.detachHost())),
        ];
        return Disposable.create(() => disposables.forEach((disposable) => disposable.dispose()));
    }
    get(uri) {
        return this.documents.get(uri);
    }
    onDidOpen(fn) {
        this.onDocumentOpenCbs.push(fn);
    }
    onDidClose(fn) {
        this.onDocumentCloseCbs.push(fn);
    }
    async attachHost(document, force = false) {
        if (!this.configuration.settings.autoActivate && !force)
            return;
        document.attachHost(this.hostFactory, this.client);
        this.onDocumentOpenCbs.forEach((cb) => cb(document));
    }
    async getCredentials() {
        try {
            const result = await this.connection.sendRequest(GrammarlyLanguageServer.Client.Feature.getToken);
            if (result)
                return JSON.stringify(result);
        }
        catch (error) {
            console.error(error);
        }
        return this.connection.sendRequest(GrammarlyLanguageServer.Client.Feature.getCredentials);
    }
    async handleClose(document) {
        this.onDocumentCloseCbs.forEach((cb) => cb(document));
        document.detachHost();
    }
};
DocumentService = DocumentService_1 = __decorate([
    injectable(),
    __param(0, inject(CONNECTION)),
    __param(1, inject(SERVER)),
    __param(2, inject(CLIENT_INFO)),
    __metadata("design:paramtypes", [Object, Object, Object, ConfigurationService])
], DocumentService);

function isNumber(value) {
    return typeof value === 'number';
}

const INITIAL_WATCHER_VALUE = {};
function watch(ref, cb) {
    const getter = () => traverse(ref.value);
    let oldValue = INITIAL_WATCHER_VALUE;
    const job = () => {
        const newValue = runner();
        try {
            cb(newValue, oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue);
        }
        catch (error) {
            console.error(error);
        }
        oldValue = newValue;
    };
    const runner = effect(getter, {
        lazy: true,
        scheduler: job,
    });
    job();
    return () => {
        stop(runner);
    };
}
function watchEffect(cb) {
    const runner = effect(cb, { lazy: true });
    runner();
    return () => {
        stop(runner);
    };
}
function traverse(value, seen = new Set()) {
    if (!isObject(value) || seen.has(value)) {
        return value;
    }
    seen.add(value);
    if (isRef(value)) {
        traverse(value.value, seen);
    }
    else if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if (value instanceof Map) {
        value.forEach((_, key) => {
            // to register mutation dep for existing keys
            traverse(value.get(key), seen);
        });
    }
    else if (value instanceof Set) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}
function isObject(value) {
    return typeof value === 'object' && value !== null;
}

var GrammarlyDiagnosticsService_1;
const SOURCE = 'Grammarly';
let GrammarlyDiagnosticsService = GrammarlyDiagnosticsService_1 = class GrammarlyDiagnosticsService {
    constructor(connection, capabilities, documents, config) {
        this.connection = connection;
        this.capabilities = capabilities;
        this.documents = documents;
        this.config = config;
        this.LOGGER = new DevLogger(GrammarlyDiagnosticsService_1.name);
        this.diagnostics = new Map();
    }
    register() {
        this.capabilities.hoverProvider = true;
        this.capabilities.codeActionProvider = true;
        this.connection.onRequest(GrammarlyLanguageServer.Feature.checkGrammar, (ref) => {
            this.LOGGER.trace(`${GrammarlyLanguageServer.Feature.checkGrammar}(${JSON.stringify(ref, null, 2)})`);
            this.check(ref.uri);
        });
        this.connection.onRequest(GrammarlyLanguageServer.Feature.stop, (ref) => {
            this.LOGGER.trace(`${GrammarlyLanguageServer.Feature.stop}(${JSON.stringify(ref, null, 2)})`);
            const document = this.documents.get(ref.uri);
            if (document != null) {
                this.clearDiagnostics(document);
                this.connection.sendRequest(GrammarlyLanguageServer.Client.Feature.updateDocumentState, { uri: document.uri });
                document.detachHost();
            }
        });
        this.connection.onRequest(GrammarlyLanguageServer.Feature.getDocumentState, (ref) => {
            this.LOGGER.trace(`${GrammarlyLanguageServer.Feature.checkGrammar}(${JSON.stringify(ref, null, 2)})`);
            const document = this.documents.get(ref.uri);
            if (document === null || document === void 0 ? void 0 : document.host) {
                return this.getDocumentState(document);
            }
            return null;
        });
        this.connection.onRequest(GrammarlyLanguageServer.Feature.acceptAlert, (options) => {
            var _a;
            this.LOGGER.trace(`${GrammarlyLanguageServer.Feature.acceptAlert}(${JSON.stringify(options, null, 2)})`);
            const document = this.documents.get(options.uri);
            (_a = this.diagnostics.get(options.uri)) === null || _a === void 0 ? void 0 : _a.delete(options.id);
            if (document === null || document === void 0 ? void 0 : document.host) {
                document.host.acceptAlert(options.id, options.text);
                this.sendDiagnostics(document);
            }
        });
        this.connection.onRequest(GrammarlyLanguageServer.Feature.dismissAlert, (options) => {
            var _a;
            this.LOGGER.trace(`${GrammarlyLanguageServer.Feature.dismissAlert}(${JSON.stringify(options, null, 2)})`);
            const document = this.documents.get(options.uri);
            (_a = this.diagnostics.get(options.uri)) === null || _a === void 0 ? void 0 : _a.delete(options.id);
            if (document === null || document === void 0 ? void 0 : document.host) {
                document.host.dismissAlert(options.id);
                this.sendDiagnostics(document);
            }
        });
        this.documents.onDidOpen((document) => {
            if (document.host) {
                this.LOGGER.trace(`Listening Grammarly alerts for ${document.uri}`);
                this.setupDiagnostics(document);
            }
        });
        this.documents.onDidClose((document) => {
            this.LOGGER.trace(`Stopping Grammarly alerts for ${document.uri}`);
            this.clearDiagnostics(document);
        });
        this.connection.onHover(({ position, textDocument }) => {
            this.LOGGER.trace('Hover', `Incoming request for ${textDocument.uri} at`, position);
            const diagnostics = this.findDiagnosticsAt(textDocument.uri, position);
            this.LOGGER.trace('Hover', 'Active diagnostics at', diagnostics);
            const document = this.documents.get(textDocument.uri);
            if (!diagnostics.length)
                return null;
            const range = document.rangeAt(Math.min(...diagnostics.map((diagnostic) => diagnostic.start)), Math.max(...diagnostics.map((diagnostic) => diagnostic.end)));
            const hover = {
                range: range,
                contents: [],
            };
            const config = {
                isDebugMode: this.config.settings.debug,
                showDetails: this.config.settings.showExplanation,
                showExamples: this.config.settings.showExamples,
                cta: document.host.user.value.isAnonymous
                    ? '> 👉 [Login](https://www.grammarly.com/signin) to get automated fix for this issue.'
                    : document.host.user.value.isPremium
                        ? ''
                        : '> ⏫ [Upgrade](https://www.grammarly.com/upgrade) to get automated fix for this issue.',
            };
            unique(diagnostics.map((diagnostic) => diagnostic.id))
                .map((id) => document.host.getAlert(id))
                .forEach((alert, index) => {
                var _a;
                if (!alert)
                    return;
                if (alert.title) {
                    const hasFixes = alert.replacements.length;
                    hover.contents.push(toMarkdown(`#### ${alert.title}`, index === 0 ? (hasFixes ? `` : config.cta) : '', alert.explanation, config.showDetails && !alert.hidden ? alert.details : '', config.showExamples && !alert.hidden ? alert.examples : ''));
                }
                else if ((_a = alert.subalerts) === null || _a === void 0 ? void 0 : _a.length) {
                    const hasFixes = alert.subalerts.every((alert) => !!alert.transformJson.alternatives);
                    const count = alert.subalerts.length;
                    hover.contents.push(toMarkdown(`### ${alert.cardLayout.outcome}`, index === 0 ? (hasFixes ? `` : config.cta) : '', alert.cardLayout.outcomeDescription, '<p></p>', `*There ${count > 1 ? 'are' : 'is'} ${count} such ${count > 1 ? 'issues' : 'issue'} in this document.*`));
                }
                else {
                    const hasFixes = alert.replacements.length;
                    hover.contents.push(toMarkdown(`### ${alert.cardLayout.outcome}`, index === 0 ? (hasFixes ? `` : config.cta) : '', alert.cardLayout.outcomeDescription));
                }
                if (config.isDebugMode) {
                    hover.contents.push({ value: JSON.stringify(alert, null, 2), language: 'json' });
                }
            });
            this.LOGGER.trace('Hover', 'Sending', hover);
            return hover;
        });
        this.connection.onCodeAction(async ({ textDocument, context }) => {
            const document = this.documents.get(textDocument.uri);
            const diagnostics = context.diagnostics.filter((diagnostic) => diagnostic.source === SOURCE);
            this.LOGGER.trace(`CodeAction in ${textDocument.uri}`, diagnostics);
            const actions = [];
            const showDeletedText = this.config.settings.showDeletedTextInQuickFix;
            if (diagnostics.length >= 1 && (document === null || document === void 0 ? void 0 : document.host)) {
                const diagnostic = diagnostics[0];
                const alert = document.host.getAlert(diagnostic.code);
                if (alert) {
                    if (isNumber(alert.begin) && alert.replacements.length > 0) {
                        const replacementRange = document.rangeAt(alert.begin, alert.end);
                        alert.replacements.forEach((newText, index) => {
                            actions.push({
                                title: `${alert.minicardTitle}${showDeletedText ? `: "${document.getText(replacementRange)}"` : ''} -> "${newText}"`,
                                kind: CodeActionKind.QuickFix,
                                diagnostics: diagnostics,
                                isPreferred: index === 0,
                                command: {
                                    command: 'grammarly.callback',
                                    title: '',
                                    arguments: [
                                        {
                                            method: GrammarlyLanguageServer.Feature.acceptAlert,
                                            params: { id: alert.id, text: newText, uri: textDocument.uri },
                                        },
                                    ],
                                },
                                edit: {
                                    changes: {
                                        [textDocument.uri]: [
                                            {
                                                range: replacementRange,
                                                newText: newText,
                                            },
                                        ],
                                    },
                                },
                            });
                        });
                    }
                    else if (alert.subalerts != null) {
                        const len = Math.min(...alert.subalerts.map(subalert => subalert.transformJson.alternatives.length));
                        const subAlerts = alert.subalerts.slice();
                        subAlerts.sort((a, b) => b.transformJson.context.s - a.transformJson.context.s);
                        for (let i = 0; i < len; ++i) {
                            const { label, highlightText } = alert.subalerts[i];
                            actions.push({
                                title: `REPLACE ALL: ${alert.minicardTitle}${label === highlightText ? '' : ` (${label})`} -> "${highlightText}"`,
                                kind: CodeActionKind.QuickFix,
                                diagnostics: diagnostics,
                                command: {
                                    command: 'grammarly.callback',
                                    title: '',
                                    arguments: [
                                        {
                                            method: GrammarlyLanguageServer.Feature.acceptAlert,
                                            params: { id: alert.id, uri: textDocument.uri },
                                        },
                                    ],
                                },
                                edit: {
                                    changes: {
                                        [textDocument.uri]: subAlerts.map(subAlert => {
                                            const range = document.rangeAt(subAlert.transformJson.context.s, subAlert.transformJson.context.e);
                                            const oldText = document.getText(range);
                                            const newText = applyDelta(oldText, subAlert.transformJson.alternatives[i]);
                                            console.log({ oldText, newText });
                                            return { range, newText };
                                        }),
                                    },
                                },
                            });
                        }
                    }
                    actions.push({
                        title: `Ignore Grammarly issue`,
                        kind: CodeActionKind.QuickFix,
                        diagnostics: diagnostics,
                        command: {
                            command: 'grammarly.callback',
                            title: 'Grammarly: Dismiss Alert',
                            arguments: [
                                {
                                    method: GrammarlyLanguageServer.Feature.dismissAlert,
                                    params: { id: alert.id, uri: textDocument.uri },
                                },
                            ],
                        },
                    });
                }
            }
            if (process.env.NODE_ENV !== 'production')
                this.LOGGER.trace('Providing code actions', actions);
            return actions;
        });
        this.LOGGER.trace('Registering diagnostics service for Grammarly');
        return Disposable.create(() => { });
    }
    findDiagnosticsAt(uri, position) {
        const document = this.documents.get(uri);
        const diagnostics = this.diagnostics.get(uri);
        if (!document || !document.host || !diagnostics) {
            return [];
        }
        const offset = document.offsetAt(position);
        return Array.from(diagnostics.values())
            .flat()
            .filter((diagnostic) => diagnostic.start <= offset && offset <= diagnostic.end);
    }
    async check(uri) {
        const document = this.documents.get(uri);
        if (document) {
            // When host is attached onDidOpen callback would be called.
            await this.documents.attachHost(document, true);
        }
    }
    setupDiagnostics(document) {
        this.diagnostics.set(document.uri, new Map());
        const diagnostics = this.diagnostics.get(document.uri);
        document.host.onDispose(watch(document.host.alerts, (alerts) => {
            diagnostics.clear();
            alerts.forEach((alert) => {
                diagnostics.set(alert.id, this.toDiagnostics(alert, document));
            });
            this.sendDiagnostics(document, true);
        }));
        document.host.onDispose(watchEffect(() => this.sendDocumentState(document)));
        document.host.on(ResponseKind.FINISHED, () => {
            this.sendDiagnostics(document);
        });
        this.sendDiagnostics(document);
    }
    sendDocumentState(document) {
        this.connection.sendRequest(GrammarlyLanguageServer.Client.Feature.updateDocumentState, this.getDocumentState(document));
    }
    getDocumentState(document) {
        let additionalFixableErrors = 0;
        let premiumErrors = 0;
        document.host.alerts.value.forEach((error) => {
            if (!error.free)
                ++premiumErrors;
            else if (error.hidden)
                ++additionalFixableErrors;
        });
        return {
            uri: document.uri,
            score: document.host.score.value,
            status: document.host.status.value,
            scores: document.host.scores.value,
            emotions: document.host.emotions.value,
            textInfo: document.host.textInfo.value,
            totalAlertsCount: document.host.alerts.value.size,
            additionalFixableAlertsCount: additionalFixableErrors,
            premiumAlertsCount: premiumErrors,
            user: document.host.user.value,
        };
    }
    toDiagnostics(alert, document) {
        const diagnostics = [];
        if (this.config.settings.hideUnavailablePremiumAlerts && alert.hidden) {
            return [];
        }
        const severity = getAlertSeverity(alert);
        if (isNumber(alert.begin) && isNumber(alert.end)) {
            if (!alert.title) {
                this.LOGGER.warn('toDiagnostics', `Missing title`, alert);
            }
            diagnostics.push({
                id: alert.id,
                code: alert.id,
                message: toText(alert.title || alert.categoryHuman),
                range: document.rangeAt(alert.highlightBegin, alert.highlightEnd),
                source: SOURCE,
                severity: severity,
                tags: severity === DiagnosticSeverity.Hint ? [DiagnosticTag.Unnecessary] : [],
                rev: alert.rev,
                start: alert.highlightBegin,
                end: alert.highlightEnd,
            });
        }
        else if (alert.subalerts) {
            const relatedInformation = [];
            alert.subalerts.forEach((subalert, i) => {
                const { s: start } = subalert.transformJson.context;
                let highlightBegin = 0;
                let highlightEnd = 0;
                let range = {};
                subalert.transformJson.highlights.forEach((highlight, j) => {
                    const s = start + highlight.s;
                    const e = start + highlight.e;
                    const r = document.rangeAt(s, e);
                    if (j <= i) {
                        highlightBegin = s;
                        highlightEnd = e;
                        range = r;
                    }
                    relatedInformation.push({ location: { uri: document.uri, range: r }, message: subalert.highlightText });
                });
                diagnostics.push({
                    id: alert.id,
                    code: alert.id,
                    message: toText(alert.title || alert.categoryHuman),
                    range: range,
                    source: SOURCE,
                    severity: severity,
                    relatedInformation,
                    rev: alert.rev,
                    start: highlightBegin,
                    end: highlightEnd,
                });
            });
        }
        else {
            this.LOGGER.warn('toDiagnostics', `Unhandled alert`, alert);
        }
        return diagnostics;
    }
    clearDiagnostics(document) {
        this.connection.sendDiagnostics({ uri: document.uri, version: document.version, diagnostics: [] });
    }
    sendDiagnostics(document, ignoreVersion = false) {
        var _a;
        const diagnostics = Array.from(((_a = this.diagnostics.get(document.uri)) === null || _a === void 0 ? void 0 : _a.values()) || []).flat();
        this.LOGGER.trace(`Diagnostics: Sending ${diagnostics.length} alerts`, diagnostics);
        if (ignoreVersion) {
            this.connection.sendDiagnostics({ uri: document.uri, diagnostics: diagnostics });
        }
        else {
            this.connection.sendDiagnostics({ uri: document.uri, version: document.version, diagnostics: diagnostics });
        }
    }
};
GrammarlyDiagnosticsService = GrammarlyDiagnosticsService_1 = __decorate([
    injectable(),
    __param(0, inject(CONNECTION)),
    __param(1, inject(SERVER)),
    __metadata("design:paramtypes", [Object, Object, DocumentService,
        ConfigurationService])
], GrammarlyDiagnosticsService);
function toText(...html) {
    return html
        .filter((value) => typeof value === 'string')
        .join('\n\n')
        .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
        .replace(/<p>/gi, '\n\n') // Explanation has unclosed <p> tag.)
        .replace(/<br\/>/gi, '  \n')
        .replace(/<[a-z][^/>]*?\/?>/gi, '')
        .replace(/<\/[a-z][^>]*?>/gi, '')
        .replace(/\n{3,}/g, '\n\n') // Remove unnecessary empty lines.
        .trim();
}
function toMarkdown(...html) {
    return html
        .filter((value) => typeof value === 'string')
        .join('\n\n')
        .replace(/<b>(.*?)<\/b>/gi, '**$1**')
        .replace(/<i>(.*?)<\/i>/gi, '*$1*')
        .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
        .replace(/<p>/gi, '\n\n') // Explanation has unclosed <p> tag.)
        .replace(/<br\/>/gi, '  \n')
        .replace(/<span class="red">/gi, '❌ <span style="color:#FF0000">')
        .replace(/<span class="green">/gi, '✅ <span style="color:#00FF00">')
        .replace(/\n{3,}/g, '\n\n') // Remove unnecessary empty lines.
        .trim();
}
function unique(items) {
    return Array.from(new Set(items));
}
function getAlertSeverity(alert) {
    if (alert.impact === 'critical')
        return DiagnosticSeverity.Error;
    switch (alert.cardLayout.outcome.toLowerCase()) {
        case 'clarity':
        case 'engagement':
            return DiagnosticSeverity.Information;
        case 'tone':
            return DiagnosticSeverity.Warning;
        case 'vox':
            return DiagnosticSeverity.Hint;
        case 'correctness':
        case 'other':
        default:
            return DiagnosticSeverity.Error;
    }
}

function startLanguageServer() {
    const disposables = [];
    const capabilities = {};
    const container = new Container({
        autoBindInjectable: true,
        defaultScope: 'Singleton',
    });
    const connection = createConnection(ProposedFeatures.all);
    container.bind(CONNECTION).toConstantValue(connection);
    container.bind(SERVER).toConstantValue(capabilities);
    connection.onInitialize((params) => {
        var _a;
        container.bind(CLIENT).toConstantValue(params.capabilities);
        container.bind(CLIENT_INFO).toConstantValue((_a = params.clientInfo) !== null && _a !== void 0 ? _a : { name: '' });
        disposables.push(container.get(ConfigurationService).register(), container.get(DocumentService).register(), container.get(DictionaryService).register(), container.get(GrammarlyDiagnosticsService).register());
        return {
            serverInfo: {
                name: 'Grammarly',
            },
            capabilities,
        };
    });
    connection.onExit(() => {
        disposables.forEach((disposable) => disposable.dispose());
    });
    connection.listen();
}

export { GrammarlyLanguageServer, startLanguageServer };
//# sourceMappingURL=index.esm.js.map
